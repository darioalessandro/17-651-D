\documentclass{article}\usepackage{amsfonts,enumerate,zed-csp}\input{handout}\newcommand{\Until}{\,\mathcal{U}\,}\newcommand{\Next}{\bigcirc}\begin{document}\homework{}{7 November 2016}{Homework \#11: Concurrency Modeling and LTL}{}\begin{enumerate}\item Exercises from MK06. ({\sc Note}: For every question in which you are asked to use LTSA, you should include the relevant output of the checker and briefly explain those results.)\begin{enumerate}\item 5.4 (just the FSP part)  The Dining Savages: A tribe of savages eats communal dinners from a large pot that can hold M servings of stewed missionary. When a savage wants to eat, he helps himself from the pot unless it is empty in which case he waits for the pot to be filled. If the pot is empty, the cook refills the pot with M servings. The behavior of the savages and the cook is described by:  \begin{verbatim}  SAVAGE = (getserving -> SAVAGE).  COOK   = (fillpot -> COOK).  \end{verbatim}  Model the behavior of the pot as an FSP process and then implement it as a Java monitor. \\  \\  \begin{verbatim}  const PotCapacity = 5  range Int = 0..PotCapacity  SAVAGE = (getserving -> SAVAGE).  COOK   = (fillpot -> COOK).  POT(I=0) = POTIMP[I],  POTIMP[n:Int] = (when(n > 0) getserving -> POTIMP[n-1]                  |when(n == 0) fillpot -> POTIMP[PotCapacity]                  ).  ||FEAST(N=5) = (forall [i:1..N] savage[i]:SAVAGE || COOK || POT(PotCapacity))                 /{{savage[1..N]}.getserving/getserving}.  \end{verbatim}\item 6.2  One solution to the Dining Philosophers problem permits only four philosophers to sit down at the table at the same time. Specify a BUTLER process which, when composed with the model of section 6.2, permits a maximum of four philosophers to engage in the sitdown action before an arise action occurs. Show that this system is deadlock-free.\begin{verbatim}const N = 5PHIL = (butler.requestSitdown->right.get->left.get               ->eat->left.put->right.put               -> butler.arise->PHIL).FORK = (get -> put -> FORK).BUTLER = BUTLER[0],BUTLER[n:0..(N-1)] =(when (n<(N-1)) requestSitdown -> BUTLER[n+1]|arise -> BUTLER[n-1]).||DINERS =        (forall [i:0..N-1] phil[i]:PHIL || {phil[i:0..(N - 1)]}::butler:BUTLER        || forall [i:0..N-1] {phil[i].left,phil[((i-1)+N)%N].right}::FORK        ).  \end{verbatim}\item 6.4  It is possible for the following system to deadlock. Explain how this deadlock occurs and relate it to one of the four necessary and sufficient conditions for deadlock to occur.    \begin{verbatim}    Alice = (call.bob -> wait.chris -> Alice).    Bob   = (call.chris -> wait.alice -> Bob).    Chris = (call.alice -> wait.bob -> Chris).    ||S = (Alice || Bob || Chris) /{call/wait}.\end{verbatim}    Given that the label rewrite maps all the calls to the wait prefixes, that means that the system can be rewriten as:    \begin{verbatim}    Alice = (bob -> chris -> Alice).    Bob   = (chris -> alice -> Bob).    Chris = (alice -> bob -> Chris).    ||S = (Alice || Bob || Chris).\end{verbatim}    It can be seen that Alice tries to execute bob, but because Chris also defines an action called bob, then Alice gets stuck.    Chris can not make any progress either as it is waiting for Bob to get to the alice action, and Bob is waiting for Alice to get to the chris action. \\    \\    In my opinion, this is an example of ``Wait-for-cycle'': ``a circular chain (or cycle) of processes exists such that each process holds a resource which its successor in the cycle is waiting to acquire.''[MK06]\\  \item 7.1     What action trace violates the following safety property?    \begin{verbatim}      property PS = (a->(b->PS|a->PS)|b->a->PS).    \end{verbatim}   $bad\_trace = \langle b, b \rangle$ \\   \item 7.2     A lift has a maximum capacity of ten people. In the model of the lift control system, passengers entering a lift are signaled by an enter action and passengers leaving the lift are signaled by an exit action. Specify a safety property in FSP which when composed with the lift will check that the system never allows the lift that it controls to have more than ten occupants. \\\begin{verbatim}  property RESPECT_MAX_OCCUPANCY[p:Passengers] = (when(p < 10) enter -> RESPECT_MAX_OCCUPANCY(p + 1)                                                 |exit -> RESPECT_MAX_OCCUPANCY(p - 1)                                                 ).  \end{verbatim}  \item 7.3    Specify a safety property for the car park problem of Chapter 5, which asserts that the car park does not overflow. Specify a progress property which asserts that cars eventually enter the car park. If car departure is lower priority than car arrival, does starvation occur? \\\begin{verbatim}businessman\end{verbatim}\end{enumerate}\item Using the semantic rules for LTL covered in the lecture on that topic, expand the following temporal formulas to their equivalent semantic form (using the $(\sigma,i)\models P)$  representation). For each, say what it means in English.\begin{enumerate}\item $Q \implies \Diamond \Box P$ \\  $(\sigma,1)\models Q \implies (\sigma,1)\models \Diamond \Box P$ \\  Q implies that eventually P will be true forever. \\\item $\Diamond (Q \land \Box P)$ \\  $\Diamond ((\sigma,1)\models Q \land (\sigma,1)\models  \Box P))$ \\  Eventually Q and always P \\\end{enumerate}\item Translate each of the following into a formula of linear temporal logic. (\textsc{Note}: For this assignment, use only the temporal logic operators: $\Box$, $\Diamond$, $\Next$, $\Until$, $\Until_w$.)\begin{enumerate}\item $p$ is sometimes true and sometimes false. \\$ \Diamond p \land \Diamond \neg p $\item $p$ and $q$ are never true together. \\$ \neg \Diamond ( q \land r) $\item $q$ and $r$ are both eventually false. \\$ \Diamond ( \neg q \land \neg r) $  \item $q$ and $r$ are eventually both false.\item If $p$ is never true, then $q$ is always true. \\  $\neg \Box p \implies \Box q $ \item Eventually, if $p$ is true, then $q$ is also true \\  $ \Diamond (p \implies q) $\item If $p$ is eventually true, $q$ is never true.  $ \Diamond p \implies \neg \Box q $\item $p$ is true finitely often (and at least once).\item If $p$ is initially true, then it will be true infinitely often; otherwise it will never be true. \\  $p \implies \Box p$ \item $p$ is initially true and thereafter alternates between being true and being false (i.e., if $(\sigma,i)\models p$, then $(\sigma,i+1)\models \neg p$ and if $(\sigma,i)\models \neg p$, then $(\sigma,i+1)\models p$). \\  I know that here we have to use the $\Next$ operator but I am not sure how to go about that.  \end{enumerate}\end{enumerate}\end{document}